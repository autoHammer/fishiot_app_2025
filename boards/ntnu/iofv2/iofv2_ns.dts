/dts-v1/;
#include <nordic/nrf9160ns_sica.dtsi>
#include "iofv2-pinctrl.dtsi"
/ {
	model = "IoFv2 nRF9160 ns";
	compatible = "ntnu-cybernetics,iofv2-nrf9160-ns";

	chosen {
		zephyr,flash = &flash0;
		zephyr,console = &uart0;
		zephyr,shell-uart = &uart0;
		zephyr,uart-mcumgr = &uart0;
	};

	leds {
		compatible = "gpio-leds";
		led1: led_1 {
			gpios = <&gpio0 2 0>;
			label = "Red LED1";
		};

		led2: led_2 {
			gpios = <&gpio0 3 0>;
			label = "Red LED2";
		};

		led3: led_3 {
			gpios = <&gpio0 4 0>;
			label = "Red LED3";
		};

		led4: led_4 {
			gpios = <&gpio0 5 0>;
			label = "Red LED4";
		};
	};

	rs485_ctrl: rs485_ctrl { 
		compatible = "gpio-leds"; 
		re_low_pin: re_low_pin { 
			gpios = <&gpio0 14 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>; 
			label = "RS485 RE Low"; 
		}; 
		de_high_pin: de_high_pin { 
			gpios = <&gpio0 15 (GPIO_ACTIVE_HIGH | GPIO_PULL_DOWN)>; 
			label = "RS485 DE High"; 
		}; 
	};

	buttons {
		compatible = "gpio-keys";
		button1: button_1 {
			gpios = <&gpio0 6 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>;
			label = "Push button 1";
		};

		button2: button_2 {
			gpios = <&gpio0 7 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>;
			label = "Push button 2";
		};
	};

	rtc {
		compatible = "gpio-keys";
		rtc_int: rtc_int_pin {
			gpios = <&gpio0 12 GPIO_ACTIVE_LOW>;
			label = "rtc_int";
    	};

		tbr_pps: tbr_pps_pin {
			gpios = <&gpio0 16 GPIO_ACTIVE_HIGH>;	// TODO: double check if active high or low!
			label = "tbr_pps";
		};

	};



	aliases {
		led0 = &led1;
		led1 = &led2;
		led2 = &led3;
		led3 = &led4;
		sw0  = &button1;
		sw1  = &button2;
		dehighpin = &de_high_pin;
		relowpin = &re_low_pin;
		bootloader-led0 = &led1;
		mcuboot-button0 = &button1;
		mcuboot-led0 = &led1;
		watchdog0 = &wdt0;
		nintpinlow = &rtc_int;
        tbrppspin  = &tbr_pps;
	};

	zephyr,user {
		io-channels = <&adc 0>;
	};
};

// TODO Look at partition and MCUboot. Is static partition needed? Is it possible to update code thorugh USB instead of SEGGER? 

&gpio0 {
	status = "okay";
};

&gpiote {
	status = "okay";
};


&uart0 {
	status = "okay";
	pinctrl-0 = <&uart0_default>;
	pinctrl-1 = <&uart0_sleep>;
	pinctrl-names = "default", "sleep";
	current-speed = <115200>;
	label = "USB Uart debug";
};

&uart1 {
	status = "okay";
	pinctrl-0 = <&uart1_default>;
	pinctrl-1 = <&uart1_sleep>;
	pinctrl-names = "default", "sleep";
	current-speed = <9600>;
	parity = "none";
	/* Flow control is off by default; keep 8N1 as per TBR Live docs. */
};

&i2c2 {
	status = "okay";
	pinctrl-0 = <&i2c2_default>;
	pinctrl-1 = <&i2c2_sleep>;
	pinctrl-names = "default", "sleep";
	label = "I2C RTC RV3032";

	rv3032: rv3032@51{
        compatible = "i2c-device";
        reg = < 0x51 >;
        label = "RTC";
    };
};

&adc {
	#address-cells = <1>;
	#size-cells = <0>;
	status = "okay";
	channel@0 {
		reg = <0>;
		zephyr,gain = "ADC_GAIN_1_6";
		zephyr,reference = "ADC_REF_INTERNAL";
		zephyr,acquisition-time = <ADC_ACQ_TIME_DEFAULT>;
		zephyr,input-positive = <NRF_SAADC_AIN0>; /* P0.13 */
		zephyr,resolution = <12>;
	};
};
